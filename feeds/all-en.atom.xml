<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Marvin's Blog</title><link href="http://scalaboy.top/" rel="alternate"></link><link href="http://scalaboy.top/feeds/all-en.atom.xml" rel="self"></link><id>http://scalaboy.top/</id><updated>2015-07-31T00:00:00+08:00</updated><entry><title>《程序员修炼之道》</title><link href="http://scalaboy.top/cheng-xu-yuan-xiu-lian-zhi-dao.html" rel="alternate"></link><updated>2015-07-31T00:00:00+08:00</updated><author><name>Marvin</name></author><id>tag:scalaboy.top,2015-07-31:cheng-xu-yuan-xiu-lian-zhi-dao.html</id><summary type="html">&lt;p&gt;床边一直摆着这本书，偶尔翻一翻，遇到让自己觉得很不错的观点就记一下。不得不说，这本书的很多观点非常使用，有时候甚至让人有醍醐灌顶的感觉。本文是读书心得，参照原书，但是多有修改删减，添加自身体会。&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;知识资产&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;知识上的投资总能得到最好的汇报。　－本杰明.富兰克林&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;毫无疑问，知识永远是最重要的生产力之一。而对于程序员来讲，知识显得尤其重要。因为这个行业的特殊性，知识更迭异常迅速。虽然有些东西是万变不离其宗的，但是不可否认的是，有些技术的的确确会过时，甚至逼近一无是处。我们能做的，就是不断给自己充电。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经营知识资产&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文中提到了几种经营知识资产的办法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;定期投资&lt;/em&gt;。学海无涯，多读书，多关注技术领域，永远不要停止学习，给自己充电。这是给现在，更是给未来的自己的一个忠告。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;多元化&lt;/em&gt;。广泛涉猎，不要局限于某一个特定的技术领域，培养全方位立体的认知体系，从各个角度思考问题。个人认为，这个多元化应该超出技术范围，人文领域的东西也许能带来更多启发。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;管理风险&lt;/em&gt;。学习新知识不代表应该随大流，见别人学什么自己学什么。人的精力是有限的，要认真评估相关知识的潜力，可能带来的收益，投入产出比。当然，这种评估很多时候是形而上的，这就需要多下功夫了解，多向高手讨教。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;温故知新&lt;/em&gt;。知识需要温习，要学会温习。随着人阅历，知识储备的增加，看问题的高度和深度不同，曾经学过的东西复习的时候很可能获得新的启发。况且，温习巩固已有的东西本来就是很重要的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;每年至少学习一门新语言&lt;/em&gt;。新语言不是万能的，但是不会新语言是万万不能的。新语言往往代表着学界工业界对于编程语言能带来的东西的期望，也预示着发展方向。比如近些年具备大规模并行支持的语言盛行。本人是Scala拥趸，对于Clojure、haskell、Go、Erlang都有兴趣，当然还有rust。下一门准备看Clojure，看看这个比Scala纯的函数式语言是什么样子。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;每季度阅读一本技术书籍&lt;/em&gt;。这个要求我觉得不算高，不过我个人更倾向于手边有书随时看，而不拘泥与看哪一本。关键是：看！&lt;/li&gt;
&lt;li&gt;&lt;em&gt;阅读非技术书籍&lt;/em&gt; 。强烈推荐，抛开一切，技术只能让你收入更高，效率更高，但是人活着不能只为了工作。“杂书”教会你生活。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;参与开源项目和社区&lt;/em&gt;。这是我期望将来能做到的，和大家一起交流学习进步，其乐无穷。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;</summary><category term="程序员修炼之道"></category><category term="读书笔记"></category></entry><entry><title>Java NIO-3 Channel</title><link href="http://scalaboy.top/java-nio-3-channel.html" rel="alternate"></link><updated>2015-07-31T00:00:00+08:00</updated><author><name>Marvin</name></author><id>tag:scalaboy.top,2015-07-31:java-nio-3-channel.html</id><summary type="html">&lt;p&gt;Java NIO通道和流在很多方面比较相似，但是还是有一些区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你可以向一个通道中写入或者读出数据，但是流只能单向操作（读或者写）&lt;/li&gt;
&lt;li&gt;通道支持异步读写&lt;/li&gt;
&lt;li&gt;通道总是和Buffer同时出现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正如上面提到的，你可以从通道中读取数据到缓冲区中，也可以将缓冲区中的数据写入通道。下图是一个简单描述：&lt;/p&gt;
&lt;p&gt;&lt;img alt="1" src="http://scalaboy.top/blogPicture/overview-channels-buffers.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;ensp;&amp;ensp;Java NIO：通道读数据到缓冲区，缓冲区写数据到通道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java NIO中有几种最重要的通道实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FileChannel&lt;/li&gt;
&lt;li&gt;DatagramChannel&lt;/li&gt;
&lt;li&gt;SocketChannel&lt;/li&gt;
&lt;li&gt;ServerSocketChannel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;FileChannel&lt;/em&gt; 负责读写文件。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;DatagramChannel&lt;/em&gt; 利用UDP协议读写数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SocketChannel&lt;/em&gt; 利用TCP协议读写数据。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ServerSocketChannel&lt;/em&gt; 允许你监听TCP连接，正如web服务器所做的那样。对于每个进入的连接会相应创建一个SocketChannel。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的例子&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    RandomAccessFile aFile = new RandomAccessFile(&amp;quot;data/nio-data.txt&amp;quot;, &amp;quot;rw&amp;quot;);
    FileChannel inChannel = aFile.getChannel();

    ByteBuffer buf = ByteBuffer.allocate(48);

    int bytesRead = inChannel.read(buf);
    while (bytesRead != -1) {

      System.out.println(&amp;quot;Read &amp;quot; + bytesRead);
      buf.flip();

      while(buf.hasRemaining()){
          System.out.print((char) buf.get());
      }

      buf.clear();
      bytesRead = inChannel.read(buf);
    }
    aFile.close();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意其中的buf.flip()调用。首先将数据读入Buffer，之后flip，然后将数据读出。&lt;/p&gt;</summary><category term="NIO"></category><category term="教程"></category><category term="JAVA"></category></entry><entry><title>Scala Array Pattern Matching问题</title><link href="http://scalaboy.top/scala-array-pattern-matchingwen-ti.html" rel="alternate"></link><updated>2015-07-31T00:00:00+08:00</updated><author><name>Marvin</name></author><id>tag:scalaboy.top,2015-07-31:scala-array-pattern-matchingwen-ti.html</id><summary type="html">&lt;p&gt;问题如下：给出两个整数队列，合并并排序。&lt;/p&gt;
&lt;p&gt;这个问题并不难，Scala提供的工具函数可以很简单的解决。首先定义变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;val a = Array(1,3,5)
val b = Array(2,4,6)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里声明两个数组a和b，如下是解决办法。&lt;/p&gt;
&lt;h4&gt;第一种方法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;(a ++ b).sorted
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个方法通俗易懂，不多加解释了。&lt;/p&gt;
&lt;h4&gt;第二种方法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;def mergeSort(a: Array[Int], b: Array[Int],ans:ArrayBuffer[Int]): Array[Int] = {
(a, b) match {
    case (Array(m, _*), Array(n, _*)) =&amp;gt; if (m &amp;lt; n) {
        ans += m
        mergeSort(a.tail, b,ans)
      } else {
        ans += n
        mergeSort(a, b.tail,ans)
      }
    case (_, Array()) =&amp;gt; ans ++= a
    case (Array(),_) =&amp;gt; ans ++= b
      }
    ans.toArray
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;利用数组进行模式匹配，递归，逐个选出当前最小的元素加入结果队列。&lt;/p&gt;
&lt;h4&gt;第三种方法&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;def listMergeSort(a: List[Int], b: List[Int],ans:ListBuffer[Int]): Array[Int] = {
  (a, b) match {
    case (m::x, n::y) =&amp;gt; if (m &amp;lt; n) {
      ans += m
      listMergeSort(x,b,ans)
    } else {
      ans += n
      listMergeSort(a, y,ans)
    }
    case (Nil,_)=&amp;gt; ans ++= b
    case (_, Nil) =&amp;gt; ans ++= a
  }
  ans.toArray
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方法略显笨重，将队列先转换为List，利用List来进行模式匹配获得结果，用最熟悉的方式解决问题。&lt;/p&gt;</summary><category term="Scala"></category><category term="Array"></category><category term="Pattern Matching"></category></entry><entry><title>Java NIO-1 教程</title><link href="http://scalaboy.top/java-nio-1-jiao-cheng.html" rel="alternate"></link><updated>2015-07-29T00:00:00+08:00</updated><author><name>Marvin</name></author><id>tag:scalaboy.top,2015-07-29:java-nio-1-jiao-cheng.html</id><summary type="html">&lt;p&gt;Java NIO(New IO)是Java API中一个可选的IO接口，可以用来作为标准Java IO和Java网络接口之外的一个选择方案。Java NIO提供一个不同和标准IO不同的IO方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java NIO：通道和缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在标准的IO API中，通信是以字节流或者字符流来进行的。而在NIO中则需要和通道（channel）以及缓冲区（buffers）打交道。数据通常由通道读入缓冲区，或者由缓冲区写入通道。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java NIO：非阻塞IO&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java支持非阻塞模式的IO。例如，一个线程可以请求通道将数据读入缓冲区，而当通道在将数据读入缓冲区的同时，线程可以转头去做其它工作。一旦数据被完全读入缓冲区，线程可以再回来继续处理。将数据写入通道的操作模式也类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java NIO：Selectors&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java NIO包含“选择器”（selectors）的概念。一个选择器是一个可以监控多个通道事件（连接打开，数据到达等）的对象。通过这种方式，一个线程可以监控多个通道内的数据。&lt;/p&gt;</summary><category term="NIO"></category><category term="教程"></category><category term="JAVA"></category></entry><entry><title>Java NIO-2 概述</title><link href="http://scalaboy.top/java-nio-2-gai-shu.html" rel="alternate"></link><updated>2015-07-29T00:00:00+08:00</updated><author><name>Marvin</name></author><id>tag:scalaboy.top,2015-07-29:java-nio-2-gai-shu.html</id><summary type="html">&lt;p&gt;Java NIO包含如下核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通道&lt;/li&gt;
&lt;li&gt;缓冲区&lt;/li&gt;
&lt;li&gt;选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java NIO除了这写还有很多类和组件，但是我认为这三者是API的核心。其它组件，例如管道（Pipe）和文件锁（FileLock）等仅仅是辅助联结这三个核心组件进行工作的工具类。因此，我将会在本章重点讲这三个组件。其它组件将会在其它章节涉及。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道和缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的IO和NIO都是由通道开始。一个通道就像一个流。数据可以从通道读入缓冲区，也可以由缓冲区写入通道。下图是一个简单描述：
&lt;p align="center"&gt;
    &lt;img src="http://scalaboy.top/images/overview-channels-buffers.png" /&gt;
&lt;/p&gt;
&lt;p align="center"&gt;
&lt;strong&gt;Java NIO：通道读数据到缓冲区，缓冲区写数据到通道&lt;/strong&gt;
&lt;/p&gt;
通道和缓冲区有很多类型。如下列举了Java NIO实现的一些初级通道类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FileChannel&lt;/li&gt;
&lt;li&gt;DatagramChannel&lt;/li&gt;
&lt;li&gt;SocketChannel&lt;/li&gt;
&lt;li&gt;ServerSocketChannel&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不难看出，这些通道的类型覆盖了UDP+TCP网络IO，还有文件IO
如下是Java NIO中实现的核心缓冲区的列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些缓冲区覆盖了IO中可以利用的数据的基本类型：byte，short，int，long，float，double和characters。
Java NIO也有MappedByteBuffer，可以结合内存映射文件使用。这部分将会留到介绍缓冲区的章节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择器&lt;/strong&gt;
通过选择器可以实现单个线程处理多个通道事件。如果你的应用存在同时有多个连接打开，而每个连接的通信量不大的情况，那么这将会带来巨大便利。例如，你的应用是聊天程序。
如下是单个线程利用选择器处理处理三个通道的示意图：
&lt;p align="center"&gt;
    &lt;img src="http://scalaboy.top/images/overview-selectors.png" /&gt;
&lt;/p&gt;
&lt;p align="center"&gt;
&lt;strong&gt;Java NIO：单线程利用选择器处理多通道&lt;/strong&gt;
&lt;/p&gt;
首先要注册通道到选择器，之后通过调用select()开始工作。这个方法将会阻塞线程直到某个已经注册的通道完成工作并触发事件。一旦方法返回，线程就可以着手处理这些事件。&lt;/p&gt;</summary><category term="NIO"></category><category term="教程"></category><category term="JAVA"></category></entry><entry><title>Java NIO 前言</title><link href="http://scalaboy.top/java-nio-qian-yan.html" rel="alternate"></link><updated>2015-07-29T00:00:00+08:00</updated><author><name>Marvin</name></author><id>tag:scalaboy.top,2015-07-29:java-nio-qian-yan.html</id><summary type="html">&lt;p&gt;在网上看到一篇很不错的Java NIO的教程，相信google过的同学都看到过，地址：http://tutorials.jenkov.com/java-nio/index.html。&lt;/p&gt;
&lt;p&gt;我想翻译过来，方便日后学习同时可以自己增加一些理解。&lt;/p&gt;</summary><category term="NIO"></category><category term="教程"></category><category term="JAVA"></category></entry><entry><title>琐话</title><link href="http://scalaboy.top/suo-hua.html" rel="alternate"></link><updated>2015-07-27T00:00:00+08:00</updated><author><name>Marvin</name></author><id>tag:scalaboy.top,2015-07-27:suo-hua.html</id><summary type="html">&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;花了两天把这个博客搭好了，是该认真分享点东西了。&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;Evernote也会随时记笔记，而且效果还不错。但是毕竟是自己看的，遇到一些难度大一点的东西，整理起来就不够细心，效果也就差不少。&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;中文资料相对较少，尤其是一些国外兴起不久的技术。希望能把自己接触到的东西，自己的理解整理分享出来。&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;开工！&lt;/p&gt;</summary><category term="博客"></category><category term="随笔"></category></entry></feed>